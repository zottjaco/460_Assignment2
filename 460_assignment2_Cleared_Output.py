# -*- coding: utf-8 -*-
"""460_Assignment2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KVvmoHVbySwPK-RUzY6AKaBE8sgqHf3v
"""

import pandas as pd

# Loading in my Excel File
import pandas as pd

file_path = "project-plan-v003.xlsx"
df = pd.read_excel(file_path)
print(df.head())

# Identify hourly rates for different roles in the sheet
hourly_rates = {
    "projectManager": 75,
    "frontendDeveloper": 60,
    "backendDeveloper": 80,
    "dataScientist": 100,
    "dataEngineer": 95
}

# Define estimated time for each task with best case, expected, and worst case outlined. Identify the action next to each set of values
task_time_estimates = {
    "A": (12, 15, 20),  # Describe product
    "B": (17, 18, 20),  # Develop marketing strategy
    "C": (10, 12, 15),  # Design brochure
    "D": (40, 60, 50),  # Develop product prototype

    # Subtasks for software development broken down
    "D1": (8, 10, 12),  # Requirements analysis
    "D2": (12, 15, 22),  # Database setup
    "D3": (20, 25, 30),  # API development
    "D4": (18, 21, 24),  # Frontend design
    "D5": (25, 30, 35),  # Backend implementation
    "D6": (7, 10, 15),  # UI/UX improvements
    "D7": (10, 12, 15),  # Testing
    "D8": (8, 10, 12),  # Deployment

    "E": (10, 12, 15),  # Develop user guide
    "F": (8, 10, 12),  # Setup cloud hosting
    "G": (12, 15, 18),  # Marketing & PR launch
    "H": (10, 12, 15),  # Final documentation & training
}

# Assign team members based on the tasks
task_roles = {
    "A": ["projectManager"],
    "B": ["projectManager"],
    "C": ["frontendDeveloper"],
    "D": ["backendDeveloper", "frontendDeveloper", "dataEngineer", "dataScientist"],

    # Software development subtasks
    "D1": ["projectManager", "dataEngineer"],
    "D2": ["dataEngineer", "backendDeveloper"],
    "D3": ["backendDeveloper", "dataEngineer"],
    "D4": ["frontendDeveloper"],
    "D5": ["backendDeveloper"],
    "D6": ["frontendDeveloper", "dataScientist"],
    "D7": ["backendDeveloper", "frontendDeveloper", "dataScientist"],
    "D8": ["backendDeveloper", "frontendDeveloper", "dataEngineer"],

    "E": ["projectManager", "frontendDeveloper"],
    "F": ["backendDeveloper", "dataEngineer"],
    "G": ["projectManager"],
    "H": ["projectManager", "dataScientist"],
}

# Update DF with new values
for index, row in df.iterrows():
    task_id = row["taskID"]

# Update time estimations
    if task_id in task_time_estimates:
        df.at[index, "bestCaseHours"] = task_time_estimates[task_id][0]
        df.at[index, "expectedHours"] = task_time_estimates[task_id][1]
        df.at[index, "worstCaseHours"] = task_time_estimates[task_id][2]

# Update assigned personnel with estimated number of workers per role
    if task_id in task_roles:
        for role in task_roles[task_id]:
            df.at[index, role] = 1  # One Person per Role

# Save the updated file for Jupyter Notebook import
updated_file_path = "project-plan-v003.xlsx"
df.to_excel(updated_file_path, index=False)

#Display new results
print (df.head())

import networkx as nx
import matplotlib.pyplot as plt

# Create a directed graph
Graph = nx.DiGraph()

# Add in the tasks and dependencies
for _, row in df.iterrows():
    task = row["taskID"]
    predecessors = str(row["predecessorTaskIDs"])

    G.add_node(task, label=row["task"])

    if predecessors and predecessors != "nan":
        for pred in predecessors.split(","):
            pred = pred.strip()
            G.add_edge(pred, task)

# Draw the directed graph with better positioning for the tasks
plt.figure(figsize=(12, 8))
pos = nx.spring_layout(G, seed=42) # positioning code
nx.draw(G, pos, with_labels=True, node_color="lightblue", edge_color="gray", node_size=2000, font_size=10, font_weight="bold")

from pulp import LpProblem, LpMinimize, LpVariable

import pandas as pd

# Load the updated Excel file with task data
file_path = "project-plan-v003.xlsx"
df = pd.read_excel(file_path)

# Extracting task IDs and durations
tasks = df["taskID"].tolist()
durations = {row["taskID"]: row["expectedHours"] for _, row in df.iterrows()}
predecessors = {row["taskID"]: str(row["predecessorTaskIDs"]).split(",") if pd.notna(row["predecessorTaskIDs"]) else [] for _, row in df.iterrows()}

# Define Linear Programming problem
model = LpProblem("ProjectScheduling", LpMinimize)

# Define decision variables: Start time for each task
start_times = {task: LpVariable(f"x_{task}", lowBound=0) for task in tasks}

# Define project completion time variable
T = LpVariable("T", lowBound=0)

# Objective function is to minimize the total project completion time
model += T

# Constraints: Ensure task dependencies are met
for task in tasks:
    for pred in predecessors[task]:
        pred = pred.strip()
        if pred and pred in start_times:
            model += start_times[task] >= start_times[pred] + durations[pred]

# T needs to represent the maximum project completion time here
for task in tasks:
    model += T >= start_times[task] + durations[task]

# Solve the linear programming problem
model.solve()

# Extract results
results = {task: start_times[task].varValue for task in tasks}
project_completion_time = T.varValue

# Convert results to DataFrame
results_df = pd.DataFrame.from_dict(results, orient="index", columns=["Start Time"])
results_df["Duration"] = results_df.index.map(durations)
results_df["Completion Time"] = results_df["Start Time"] + results_df["Duration"]

# Save the results
results_df.to_csv("project_schedule_results.csv", index=True)

# Display results
print(f"Total Project Completion Time: {project_completion_time} hours")
print(results_df)

!pip install plotly pandas openpyxl

# Need to extract the best, worst, and expected cases
best_case = {row["taskID"]: row["bestCaseHours"] for _, row in df.iterrows()}
expected_case = {row["taskID"]: row["expectedHours"] for _, row in df.iterrows()}
worst_case = {row["taskID"]: row["worstCaseHours"] for _, row in df.iterrows()}

# Function to compute schedule based on dependencies
def compute_schedule(duration_dict):
    """
    Finds the earliest start and completion times for tasks based on dependencies.
    Returns a dictionary with task start and completion times.
    """
    start_times = {task: 0 for task in tasks}

    for task in tasks:
        if predecessors[task]:  # If there are dependencies
            max_completion_time = 0
            for pred in predecessors[task]:
                pred = pred.strip()
                if pred and pred in start_times:
                    pred_completion_time = start_times[pred] + duration_dict[pred]
                    max_completion_time = max(max_completion_time, pred_completion_time)
            start_times[task] = max_completion_time

    completion_times = {task: start_times[task] + duration_dict[task] for task in tasks}
    return start_times, completion_times

# Find schedules for best-case, expected, and worst-case scenarios
best_start, best_complete = compute_schedule(best_case)
expected_start, expected_complete = compute_schedule(expected_case)
worst_start, worst_complete = compute_schedule(worst_case)

# Identify critical path
def compute_critical_path(start_times, completion_times):
    """
    Identifies the critical path by finding tasks where the start time is in line with dependency completion.
    """
    critical_path = []
    for task in tasks:
        if task in predecessors:
            for pred in predecessors[task]:
                pred = pred.strip()
                if pred and pred in start_times and start_times[task] == completion_times[pred]:
                    critical_path.append(task)
    return list(set(critical_path))  # unique tasks confirmed

# Compute critical paths for each scenario
critical_path_best = compute_critical_path(best_start, best_complete)
critical_path_expected = compute_critical_path(expected_start, expected_complete)
critical_path_worst = compute_critical_path(worst_start, worst_complete)

# Prepare results for display
schedule_df = pd.DataFrame({
    "Task": tasks,
    "Best Start": [best_start[t] for t in tasks],
    "Best Completion": [best_complete[t] for t in tasks],
    "Expected Start": [expected_start[t] for t in tasks],
    "Expected Completion": [expected_complete[t] for t in tasks],
    "Worst Start": [worst_start[t] for t in tasks],
    "Worst Completion": [worst_complete[t] for t in tasks],
    "Critical Path (Best)": [t in critical_path_best for t in tasks],
    "Critical Path (Expected)": [t in critical_path_expected for t in tasks],
    "Critical Path (Worst)": [t in critical_path_worst for t in tasks],
})

# Display the DF
display(schedule_df)

# Create Gantt charts for the scenarios
def create_gantt_chart(start_times, completion_times, title):
    fig, ax = plt.subplots(figsize=(12, 6))

    # Sort tasks by start time for better visualization
    sorted_tasks = sorted(tasks, key=lambda x: start_times[x])

    for i, task in enumerate(sorted_tasks):
        ax.barh(i, completion_times[task] - start_times[task], left=start_times[task], color="skyblue", edgecolor="black")
        ax.text(start_times[task] + (completion_times[task] - start_times[task]) / 2, i, task, va="center", ha="center", fontsize=10)

    ax.set_yticks(range(len(sorted_tasks)))
    ax.set_yticklabels(sorted_tasks)
    ax.set_xlabel("Hours")
    ax.set_title(title)
    plt.grid(axis="x", linestyle="--", alpha=0.6)
    plt.show()

import matplotlib.pyplot as plt

# Display Gantt charts for all scenarios
create_gantt_chart(best_start, best_complete, "Gantt Chart - Best Case Scenario")
create_gantt_chart(expected_start, expected_complete, "Gantt Chart - Expected Case Scenario")
create_gantt_chart(worst_start, worst_complete, "Gantt Chart - Worst Case Scenario")

schedule_df.to_excel("Project_Schedule_Critical_Path.xlsx", index=False)
print("Schedule saved to Project_Schedule_Critical_Path.xlsx")

